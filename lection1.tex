\section{Лекция 1}

\subsection{$\lambda$-исчисление}

\begin{definition}[$\lambda$-выражение]
	$\lambda$-выражение "--- выражение, удовлетворяющее грамматике:
	\vspace{1mm}
	\begin{bnf}
	\begin{alignat*}{3}
		\Phi &::=& x \\
		| & \left(\Phi\right) \\
		| & \lambda{}x.\Phi \qquad && () \\
		| & \Phi \ \Phi         && () \\
	\end{alignat*}
	\end{bnf}
	\begin{enumerate}
		\item Аппликация левоассациативна.
		\item Абстракции жадные, едят все что могут.
		\vspace{1mm}
		\begin{example}
			$(\lambda{}x.(\lambda{}f.((f x) (f x) \lambda{}y.(y f))))$
		\end{example}
	\end{enumerate}
\end{definition}

Есть понятия связанного и свободного вхождения переменной (аналогично исчислению предикатов).
$\lambda{}x.A$ связывает все свободные вхождения $x$ в $A$.
\begin{definition} 
	Функция $\FV(A)$ "--- множество свободных переменных, входящих в $A$:
	\[
	\FV(A) =
	\begin{cases}
	\set{x}                  & \text{если } A \equiv x \\
	\FV(P) \cup \FV(Q)       & \text{если } A \equiv PQ \\
	\FV(P) \setminus \set{x} & \text{если } A \equiv \lambda x . P
	\end{cases}
	\]
\end{definition}

Договоримся, что:
\begin{itemize}
	\item Переменные "--- $x$, $a$, $b$, $c$.
	\item Термы (части $\lambda$-выражения) "--- $X$, $A$, $B$, $C$.
	\item Фиксированные переменные обозначаются буквами из начала алфавита, метапеременные "--- из конца.
\end{itemize}

На самом деле, смысл в этом есть, $\lambda$-выражение можно понимать как функцию.
Абстракция "--- это функция с аргументом, аппликация "--- это передача аргумента.

\begin{definition}[$\alpha$-эквивалентность]
	$A=_{\alpha}B$, если имеет место одно из следующих условий:
	\begin{enumerate}
		\item $A\equiv{}x$, $B\equiv{}y$ (x,y "--- переменные) и $x\equiv{}y$
		\item $A\equiv{}P_{1}Q_{1}$, $B\equiv{}P_{2}Q_{2}$ и $P_{1}=_{\alpha}P_{2}$, $Q_{1}=_{\alpha}Q_{2}$
		\item $A\lambda{}x.P_{1}$, $B\lambda{}y.P_{2}$и $P_{1} [x\coloneqq{}t] =_{\alpha}P_2 [y\coloneqq{}t]$, где $t$ "--- новая переменная.
	\end{enumerate} 
\end{definition}

\begin{example}
	$\lambda{}x.\lambda{}y.xy=_{\alpha}\lambda{}y.\lambda{}x.yx$.
	\begin{proof} Согласно второму правилу следующие утверждения верны:
		\begin{alignat*}{2}
		\lambda{}y.ty=_{\alpha}\lambda{}x.tx &\implies \lambda{}x.\lambda{}y.xy=_{\alpha}\lambda{}y.\lambda{}x.yx \\
		tz=_{\alpha}tz &\implies \lambda{}y.ty=_{\alpha}\lambda{}x.tx
		\end{alignat*}%
		$tz=_{\alpha}tz$ верно по третьему условию.
	\end{proof}
\end{example}

\begin{definition}[$\beta$-редекс]
	$\beta$-редекс "--- выражение вида: $\left(\lambda{}x.A\right)B$
\end{definition}

\begin{definition}[$\beta$-редукция]
	$A\to_{\beta}B$, если имеет мето одно из следующих условий:
	\begin{enumerate}
		\item $A\equiv{}P_{1}Q_{1}$, $B\equiv{}P_{2}Q_{2}$ и либо $P_{1}=_{\alpha}P_{2}$, $Q_{1}\to_{\beta}Q_{2}$, либо
		$P_{1}\to_{\beta}P_{2}$, $Q_{1}=_{\alpha}Q_{2}$
		\item $A\equiv\left(\lambda{}x.P\right) Q$, $B\equiv P[x\coloneqq{}Q]$ "--- Q свободна для подстановки вместо x в P 
	\end{enumerate}
	\begin{example} 
		$X\to_{\beta}X$, $\left(\lambda{}x.x\right) y\to_{\beta} y$
	\end{example}
	\begin{example}
		 $a \left(\lambda{}x.x\right) y\to_{\beta} a y$
	\end{example}
	\begin{example}
		$A\equiv\lambda{}x.P$, $B\equiv\lambda{}x.Q$, $P\to_{\beta}Q$
	\end{example}
\end{definition}

\subsection{Представление некоторых функций в лямбда исчислении}
Boolean значения легко представить в терминах $\lambda$-исчисления, к примеру
\begin{itemize}
	\item $True$   = $\lambda{}a\lambda{}b.a$ 
	\item $False$  = $\lambda{}a\lambda{}b.b$
\end{itemize}

\newcommand{\If}{\lambda{}c.\lambda{}t.\lambda{}e.(c t) e}
\newcommand{\T}{\lambda{}a\lambda{}b.a}
\newcommand{\F}{\lambda{}a\lambda{}b.b}



Также мы можем выражать и более сложные функции \\

\begin{example}
	$If \ T \ a \ b \to_{\beta} \ a$
	\begin{proof}
		\begin{alignat*}{2}
		 ((\If) \ \T)\ a \ b \to_{\beta} (\lambda{}t.\lambda{}.e(\T) \ t \ e) \ a \ b \to_{\beta} \ \\ (\lambda{}t.\lambda{}.e(\lambda{}b.t) \ e) \ a \ b \to_{\beta} \ (\lambda{}t.\lambda{}e.t) \ a \ b \to_{\beta} \ (\lambda{}e.a) \ b \to_{\beta} \ a
		\end{alignat*}
	\end{proof}
\end{example}

Как мы видим If true действительно возвращает результат первой ветки.


Другие логические операции:
\[
	Not = \lambda{}a.a \ F \ T \qquad
	And = \lambda{}a.\lambda{}b.a \ b \ F \qquad
	Or = \lambda{}a.\lambda{}b.a \ T \ b \qquad
\]



\subsection{Черчевские нумералы}

\begin{definition}[черчевский нумерал]
	\[
		\overline{n} = \lambda{}f.\lambda{}x.f^{n} x \text{, \quad где\quad}
		f^{n} x = 
		\begin{cases}
			f\left(f^{n-1} x\right) & \text{при } n > 0 \\
			x 						& \text{при } n = 0
		\end{cases}
	\]
\end{definition}




