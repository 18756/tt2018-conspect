\documentclass[12pt]{article}
\usepackage{amsmath} 
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{stmaryrd}
\usepackage{xcolor}
\usepackage{mathtools}% Loads amsmath
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{enumitem}
\usepackage{soul}
\usepackage{changepage}
\usepackage{lipsum}
\usepackage{scrextend}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{minted}
\usepackage{proof}
\usepackage{paracol}

\newsavebox\MBox
\newcommand\Cline[2][red]{{\sbox\MBox{$#2$}%
  \rlap{\usebox\MBox}\color{#1}\rule[-1.2\dp\MBox]{\wd\MBox}{0.5pt}}}

\title{Теория типов. 9-10 лекции}

\begin{document}


\section{Лекция 9 (30.10.2018)}

\subsection{}

\noindent\textbf{Def.} Ранг типа

$R(x)$ --- все типа ранга $x$.
\begin{itemize}
    \item $R(0)$ --- все типы без кванторов
    \item $R(x + 1) = R(x)\ |\ R(x) \rightarrow R(x + 1)\ |\ \forall \alpha.R(x + 1)$
\end{itemize}
\noindent\textbf{Enddef.} 

Например:
\begin{paracol}{2}
\begin{itemize}
    \item $\alpha \in R(0)$
    \item $\forall \alpha.\alpha \in R(1)$
    \item $(\forall \alpha.\alpha) \rightarrow (\forall b.b) \in R(2)$ 
    \item $((\forall \alpha.\alpha) \rightarrow (\forall b.b)) \rightarrow b \in R(3)$
\end{itemize}
\switchcolumn
Тут видно, если если выражение слева от знака имликации имеет ранг $n$, то все выражение будет иметь ранг $\geq (n + 1)$.
\end{paracol}

\textbf{Утверждение}: Пусть $x$ --- выражение только с поверхностными кванторами, тогда $x \in R(1)$. 

\noindent\textbf{Def.} Типовая система

$\sigma ::= \forall \alpha_1. \forall \alpha_2. \dots \forall \alpha_n. \tau$, где $\tau \in R(0)$ и, следовательно, $\sigma \in R(1)$.

\noindent\textbf{Enddef.} 

\noindent\textbf{Def.} Частный случай (спциализация) типовой схемы

$\sigma_1 \sqsubseteq \sigma_2$ --- типовая схема

$\sigma_2$ --- частный случай (специализация) $\sigma_1$, если 

\begin{enumerate}
    \item $\sigma_1 =  \forall \alpha_1. \forall \alpha_2. \dots \forall \alpha_n. \tau_1$
    \item $\sigma_2 =  \forall \beta_1. \forall \beta_2. \dots \forall \beta_n. \tau_1[\alpha_i := S(\alpha_i)]$
    \item $\forall i. \beta_i \in FV(\tau_1)$
\end{enumerate}

\noindent\textbf{Enddef.} 

\begin{paracol}{2}
\begin{itemize}[label={}]
    \item $M_1 : \forall \alpha . \alpha \rightarrow \alpha$
    \item $M : \forall \beta_1.\forall \beta_2: (\beta_1 \rightarrow \beta_2) \rightarrow (\beta_1 \rightarrow \beta_2)$
\end{itemize}
\switchcolumn
Вполне возможно, что в ходе замены, все типы будут уточнены ($\alpha$ уточниться как $\beta_1 \rightarrow \beta_2$.
\end{paracol}





\subsection{Хиндли-Милнер}

\begin{enumerate}
    \item Все типы только с поверхностными кванторами ($R(1)$)
    \item $\overline{HM} ::= p\ |\ \overline{HM}\ \overline{HM}\ |\ \lambda p. \overline{HM}\ |\ let =  \overline{HM}\ in\ \overline{HM}$
\end{enumerate}

Докажем: $\vcenter{\infer{\Gamma \vdash \exists p.\phi}{\Gamma \vdash \phi[p := \Theta]}}$
\begin{itemize}
    \item $\exists p.\phi = \forall b.(\forall p. (\phi \rightarrow b)) \rightarrow b$
    \item $\phi \rightarrow \bot \equiv \forall b. (\phi \rightarrow b)$
    
    \item $\vcenter{\infer[]{\Gamma \vdash \forall b.(\forall p.(\phi \rightarrow b)) \rightarrow b}{\infer{\Gamma \vdash (\forall p. (\phi \rightarrow b)) \rightarrow b}{\infer{\Gamma, \forall p. (\phi \rightarrow b) \vdash b}{\infer{\Gamma, \forall p. (\phi \rightarrow b) \vdash \phi [p := \Theta] \rightarrow b}{\Gamma, \forall p. (\phi \rightarrow b) \vdash \forall p.(\phi \rightarrow b)}}}}}$
    % \item $\Gamma, \forall p. (\phi \rightarrow b) \vdash \forall p.(\phi \rightarrow b)$
    % \item $\Gamma, \forall p. (\phi \rightarrow b) \vdash \phi [p := \Theta] \rightarrow b$
    % \item $\Gamma, \forall p. (\phi \rightarrow b) \vdash b$
    % \item $\Gamma \vdash (\forall p. (\phi \rightarrow b)) \rightarrow b$
    % \item $\Gamma \vdash \forall b.(\forall p.(\phi \rightarrow b)) \rightarrow b$
\end{itemize}

Соглашение:
\begin{itemize}
    \item $\sigma$ --- типовая схема
    \item $\tau$ --- простой тип
\end{itemize}


\begin{enumerate}
    \item $\vcenter{\infer{\Gamma, x : \sigma \vdash x : \sigma}{}}$
    \item $\vcenter{\infer{\Gamma \vdash e_0\ e_1 : \tau'}{\Gamma \vdash e_1 : \tau \rightarrow \tau' \qquad \Gamma \vdash e_1 : \tau}}$
    \item $\vcenter{\infer{\Gamma \vdash \lambda x.e : \tau \rightarrow \tau'}{\Gamma, x : \tau \vdash e : \tau'}}$
    \item $\vcenter{\infer[,\ let\ x = a\ in\ b \equiv (\lambda x.b)\ a]{\Gamma \vdash let\ x = e_0\ in\ e_1 : \tau}{\Gamma \vdash e_0 : \sigma \qquad \Gamma, x : \sigma \vdash e_1 : \tau}}$ 
    \item $\vcenter{\infer{\Gamma \vdash e : \sigma}{\Gamma \vdash e : \sigma' \qquad  \sigma' \sqsubseteq \sigma}}$
    \item $\vcenter{\infer[\alpha \not \in FV(\Gamma)]{\Gamma \vdash e : \forall \alpha.\sigma}{\Gamma \vdash e : \sigma}}$
\end{enumerate}


\subsection{Алгоритм вывода типов в системе Хиндли-Милнера W}
На вход подаются $\Gamma,\ M$, на выходе наиболее общая пара $(S, \tau)$
\begin{enumerate}
    \item $M = x : \tau,\ x \in \Gamma$ (иначе ошибка)
    \begin{itemize}
        \item Выбросить все кванторы из $\tau$
        \item Переименовать все свободные переменные в свежие \\
        Например: $\forall \alpha_1.\phi \Rightarrow \phi[\alpha_1 := \beta_1]$, где $\beta_1$ --- свежая переменная
    \end{itemize}
    $(\emptyset, \Gamma(x))$
    \item $M = \lambda n.e$
    \begin{itemize}
        \item $\tau$ --- новая типовая переменная
        \item $\Gamma' = \Gamma \setminus \{n : _\}$ (т.е. $\Gamma$ без переменной $n$)
        \item $\Gamma'' = \Gamma' \cup {n : \tau}$
    \end{itemize}
    \item $M = P\ Q$
    \begin{itemize}
        \item $\tau$ --- новая типовая переменная
        \item $(S_1, \tau_1) = W(\Gamma, P)$
        \item $(S_2, \tau_2) = W(S_1(\Gamma), Q)$
        \item $S_3$ --- Унификация $(S_2(\tau_1), \tau_2 \rightarrow \tau)$ $(S_3 \circ S_2 \circ S_3, S_3(\tau))$
    \end{itemize}
    \item $let\ x = P\ in\ Q$
    \begin{itemize}
        \item $(S, \tau) = W(\Gamma, P)$
        \item $\Gamma' = \Gamma$ без $x$
        \item $\Gamma'' = \Gamma' \cup \{ x : \forall \alpha_1 \dots \alpha_k. \tau_1 \}$, где $\alpha_1 \dots \alpha_k$ свободные переменные в $\tau_1$
        \item $(S_2, \tau_2) = W(S_1(\Gamma''), Q)$
        \item $(S_1 \circ S_2), \tau_2)$
    \end{itemize}
    
\end{enumerate}

Надеемся, что логика второго порядка противоречива. \\
Введем явный $Y$-комбинатор

$Y f =_\beta f (Y\ f)$

$Y : \forall \alpha . (\alpha \rightarrow \alpha) \rightarrow alpha$ --- аксиома

\begin{minted}{fsharp}
type intList = Nil | Cons of int * intList;;

let rec length l = match l with 
  | Nil -> 0
  | Cons (x, s) -> 1 + length s;;

let my_list = Cons(1, Cons (2, Cons (3, Nil)));;

print_int (length my_list);;  (* output: 3 *)
\end{minted}

$Nil = inLeft O = \lambda a. \lambda b. a\ O$ 

$Cons = inRight p = \lambda a. \lambda b. b\ p$

$\lambda a. \lambda b. a\ O : \forall \gamma .(\alpha \rightarrow \gamma) \rightarrow (\beta \rightarrow \gamma) \rightarrow \gamma$

$\lambda a. \lambda b. b\ O: \forall \gamma .(\alpha \rightarrow \gamma) \rightarrow (\beta \rightarrow \gamma) \rightarrow \gamma$

$\delta = \forall \gamma .(\alpha \rightarrow \gamma) \rightarrow (\beta \rightarrow \gamma) \rightarrow \gamma$

$\lambda a. \lambda b. b\ (\lambda a. \lambda b. a\ O) : \forall \alpha. (\alpha \rightarrow \gamma) \rightarrow (\delta \rightarrow \gamma) \rightarrow \gamma$

Научимся задавать рекурсивные типы.

\begin{enumerate}
    \item Эквирекурсивный 
    \begin{minted}{fsharp}
        list = Nil | Cons a * list
    \end{minted}
    $\alpha = f(\alpha)$ --- уравнение с неподвижной точкой. Пусть $\nu \alpha. f(\alpha) = f(\nu \alpha.f(\alpha))$. Пояснение: $Y$ --- для выражений, а для типов --- $\nu$.
    \begin{minted}{java}
        class Enum <extends Enum<E>>
    \end{minted}
    \item Изорекурсивный
    \begin{minted}{C}
    struct list {
        list x;
    }
    x.x.x.x
    \end{minted}
    $*: list* \rightarrow list$ --- разыменовывание 
    
    $Roll: Nil | Cons (a * list) \rightarrow list$
    
    $Unroll: list \rightarrow Nil | Cons (a * list)$

    Общий тип (введение в типовую систему): 
    \begin{itemize}
        \item $roll: f(\alpha) \rightarrow \alpha$
        \item $unroll: \alpha \rightarrow f(\alpha)$
    \end{itemize}
    
    Пример из Си:
    \begin{itemize}
        \item $*: T* \rightarrow T$
        \item $\&: T \rightarrow T*$
        \item $T = \alpha$
        \item $T* = f(\alpha)$
    \end{itemize}
    
    Зависимые типы и логика 1-ого порядка
    
    $sprintf : string \rightarrow smth \rightarrow string$
    
    $sprintf "\%d" : int \rightarrow string$
    
    $sprintf "\%f" : float \rightarrow string$
    
    тип sprintf определяется первым аргументом.
\end{enumerate}


\section{Лекция 10 (06.11.2019)}

\subsection{Обобщенные типовые системы}

\begin{itemize}
    
\item Сорта: \{*, \openbox\}
\begin{itemize}
    \item Выражение "$A:*$" означает, что $A$ --- тип. И тогда, если на метаязыке мы хотим сказать "Если $A$ тип, то и $A \rightarrow A$ тоже тип", то формально это выглядит как $A:* \vdash (A \rightarrow A):*$
    \item $\openbox$ - это абстракция над сортом для типов.
\end{itemize}

\item $T ::= x\ |\ c\ |\ T\ T\ |\ \lambda x:T.\ T\ | \Pi x:T.\ T$

\item Аксиома:
\begin{itemize}
    \item $\vcenter{\infer{\vdash * . \openbox}{}}$
\end{itemize}

\item Правила вывода:
\begin{enumerate}
    \item $\vcenter{\infer[x \not \in \Gamma]{\Gamma, x : A \vdash x : A}{\Gamma \vdash A:S}}$
    \item $\vcenter{\infer[\text{--- правило ослабление (примерно как } \alpha \rightarrow \beta \rightarrow \alpha \text{ в И.В.)}]{\Gamma, x : C \vdash A:B}{\Gamma \vdash A:B \qquad \Gamma C:S}}$
    \item $\vcenter{\infer[\text{--- правило конверсии}]{\Gamma \vdash A:B'}{\Gamma \vdash A:B \qquad \Gamma \vdash B':S \qquad B =_\beta B'}}$
    \item $\vcenter{\infer[\text{--- правило применения}]{\Gamma \vdash (F\ a) : B[x := a]}{\Gamma \vdash F : (\Pi x:A.B) \qquad \Gamma \vdash a : A}}$
\end{enumerate}

\item Семейства правила (generic-правила)

Пусть $(s_1, s_2) \in S \subseteq \{*, \openbox\}^2$.

\begin{enumerate}
    \item $\Pi$-правило: $\vcenter{\infer[]{\Gamma \vdash (\Pi x : A.B) : s_2}{\Gamma \vdash A : s_1 \qquad \Gamma, x : A \vdash B : s_2}}$
    \item $\lambda$-правило: $\vcenter{\infer[]{\Gamma \vdash (\lambda x : A . b) : (\Pi x : A. B)}{\Gamma \vdash A:s_1 \qquad \Gamma, x : A \vdash b : B \qquad \Gamma, x : A \vdash B : s_2}}$
\end{enumerate}

\end{itemize}

Например:
\begin{itemize}[leftmargin = 2cm]
    \item $5:int:*:\openbox$
    \item $[]:*\rightarrow*:\openbox$
    \item $\Lambda M.List<M>:*\rightarrow*\openbox$
\end{itemize}

\subsection{$\lambda$-куб}

\begin{center}
    {\includegraphics[scale=0.5]{pic.png}}
\end{center}

\textbf{Th}  

    Обобщенная типовая система сильно нормализуема

\vspace{5mm}   

Примеры:

\begin{itemize}
    \item $\lambda \omega$:
\begin{center}
    $\vdash (\lambda \alpha : * . \alpha \rightarrow \alpha) (* \rightarrow *) : \openbox$

\vspace{5mm}

\begin{enumerate}[]
    \item \begin{center}
        $\vcenter{\infer{\vdash (* \rightarrow *) : \openbox}{\vdash * : \openbox \qquad \infer{a:* \vdash *.\openbox}{\vdash *.\openbox} }}$
    \end{center}
    \item \begin{center} $\vcenter{\infer{\vdash (\lambda \alpha : * . \alpha \rightarrow \alpha) : * \rightarrow *}{\vdash * : \openbox \qquad \infer{\alpha : * \vdash \alpha \rightarrow \alpha : x}{\alpha : * \vdash \alpha : * \qquad \alpha : *, x : * \vdash \alpha : *} \qquad \infer{\vdash (* \rightarrow *) : \openbox}{\vdash * : \openbox \qquad \infer{a:* \vdash *.\openbox}{\vdash *.\openbox} } }}$
    \end{center}
\end{enumerate}
\end{center}

% \item $\lambda \rightarrow$

\end{itemize}

Notes:
\begin{itemize}
    \item $(\lambda x.x) : (A \rightarrow A)$ - implicit typing (Curry style)
    \item $I_A = \lambda x : A.x$ - explicit typing (Church style)
\end{itemize}

\end{document}
